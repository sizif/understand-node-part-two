Lecture 27: Exports vs. module exports

note: in /l27, greet.js

When our code is run through node, it's wrapped in a 
function expression, "almost an iife".

The require function returns module.exports. It's returning
the property on the module object.

However, exports does not work for all the module patterns
shown previously.

You'd think they are the same object, but they don't return the same:
console.log(exports);           // returns [Function]
console.log(module.exports);    // returns {}

There's a quirk in JS when setting a var equal to a value.

module.exports still points to an Object,
but 
exports = to a value creates a new Object in memory.

Originally, module.exports and exports were pointing to the same object in
memory, but once "exports =" was used, a new object was made and the
connection was broken.

So, when it comes to "exports" I can't override it, I can't use "equals".
However, I can change it, that is to say, I can add a new property, or a 
new method. I can cahnge it, I can mutate it.

MUTATE:
To change something.

For example, adding a method or property to an object means you've mutated
the object.

So now I'll mutate the object in greet2.js.

Run node app2.js to see the difference between greet.js module and
greet2.js module printed in node console.

Why did it work in app2, and not in app1?

IMPORTANT ANSWER: Because I simply mutated, I added, I changed the object,
I did not change the reference.
I can now call greet2.greet(), because I added the property.

I can use only "exports", but only if I mutate the object, I can't replace
the object with something else.

I like to lower my cognitive load while coding (that is, how many things I
think about at one time).

Just use module.exports!

l28: REQUIRING NATIVE (CORE) MODULES

What do they do? See here: https://nodejs.org/api/

READ IT!

To require util, I can just:

var util = require('util');

And now I have an object that has all the niceities of that utility feature.

I the meantime, in app-l28-01.js, is an example of using the util native
module in my code.


l29 - MODULES AND ES6
---------------------

The new syntax for modules in es6 is very powerful.

greet-l29-01.js and app-l29-01.js

DOES NOT WORK IN node 4.5.

l30 - WEB SERVER CHECKLIST
--------------------------
Better ways to organize code into reusable pieces
Ways to deal with files
Ways to deal with databases
The ability to communicate over the internet
the ability to accept requests and send responses (in the standard format)
A way to deal with work that takes a long time

l31 - EVENTS AND THE EVENT EMITTER
----------------------------------

System Events (C++ Core: libuv) - VS - Custom Events (JS core: event emitter)

As we're about to see, the JavaScript side is faking it, it's not
real events. Because JS does not have an eventing concept, there is
no Event object in JS.

But we can fake it, we can create our own event library, with the
technique that the node Event Emitter uses.

We'll build our own Event Emitter to understand how node uses its
Event Emmiter and all the native code that comes on top of it.









